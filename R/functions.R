### R functions used in Rmarkdown documents

### Prepare vectors of SARS-CoV-2 viral gene names
viral_genes <- factor(
  x = c("gRNA", "S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N"),
  levels = c("gRNA", "S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N")
)

### Prepare vectors of SARS-CoV-2 viral sgmRNA gene names
viral_sgmRNA <- factor(
  x = c("S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N"),
  levels = c("S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N")
)

### Prepare vectors of SARS-CoV-2 viral protein names
viral_proteins <- factor(
  x = c("pp1a", "pp1ab", "S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N"),
  levels = c("pp1a", "pp1ab", "S", "ORF3a", "E", "M", "ORF6", "ORF7a", "ORF7b", "ORF8", "N")
)

# scCoVseq Related Functions

### This function should be run on Seurat Objects generated by scCoVseq
### or other output generated by umi_tools
### UMIs assigned to multiple genes are quantified by
### umi_tools as a UMI to a conjoined gene
### For example, a UMI that aligns to both gene A and B will result in
### 1 UMI counted to "A;B" in the gene matrix
### CellRanger output excludes UMIs like this and for most scRNAseq analysis
### this is an appropriate analytical decision.
### This function searches for genes in a Seurat object containing a
### semicolon, ";", which indicates these UMIs assigned to multiple genes
### These genes are then removed and the Seurat object is
### regenerated without those ambiguous genes.
require(Seurat)
Remove_Ambiguous_UMIs <- function(Seurat_Obj) {
  ### Input:
  ### Seurat_Obj = a Seurat Object generated using scCoVseq or other umi_tools output data

  ### First define genes that do not contain a semicolon and therefore
  ### are not from UMIs assigned to multiple genes
  Unambiguous_Features <- grep(pattern = ";", x = row.names(Seurat_Obj),
                               value = TRUE, invert = TRUE)

  ### Filter Seurat_Obj to only these unambiguous genes
  Filtered_Obj <- DietSeurat(Seurat_Obj, features = Unambiguous_Features)

  ### Return the filtered object
  return(Filtered_Obj)
}

### Function to subset a cellranger output sparse matrix
### to cells contained in a whitelist
subset_to_barcodes_whitelist <- function(x, whitelist) {
  ### Inputs
  ### x = CellRanger output sparse matrix, not a Seurat Object
  ### whitelist = A character vector of cell barcodes,
  ### formatted to match CellRanger output cell barcodes, to keep for analysis

  ### Subset the object to only cells contained in the whitelist
  x <- x[, colnames(x) %in% whitelist]

  ### Return the subsetted object
  return(x)
}

### Function to subset a scCoVseq output sparse matrix
### to cells contained in a whitelist
subset_scCoVseq_to_barcodes_whitelist <- function(x, whitelist) {
  ### Inputs
  ### x = scCoVseq output sparse matrix, not a Seurat Object
  ### whitelist = A character vector of cell barcodes,
  ### formatted to match scCoVseq output cell barcodes, to keep for analysis

  ### Subset the object to only cells contained in the whitelist
  x <- x[, colnames(x) %in% str_remove(whitelist, pattern = "-1")]

  ### Return the subsetted object
  return(x)
}

### Select cells with less than 100 genes and mitochondrial gene expression
### less than 5% as empty droplets
### Sample the same number of empty droplet barcodes as number of cells in a given sample
### Create a seurat object of these sampled empty droplet barcodes
select_empty_droplets <- function(Whitelist, scCoVseq_object){
  ### Inputs:
  ### Whitelist = A character vector of cell barcodes,
  ### formatted to match scCoVseq output cell barcodes, to keep for analysis
  ### scCoVseq_Object = A Seurat object generated from data output from scCoVseq

  ### Randomly sample the same number of empty droplets
  ### as the number of cells in the whitelist
  barcodes <- WhichCells(scCoVseq_object,
                         expression = (nFeature_RNA < 100 & percent_mito < 5),
                         downsample = length(Whitelist))

  ### Subset the object to the empty droplets
  empty_droplet_object <- subset(scCoVseq_object,
                                 cells = barcodes)
  return(empty_droplet_object)
}

# Add Metadata for SARS-CoV-2 Infection
### This function calculates the total viral UMIs per cell in a Seurat object
calculate_viral_nUMIs <- function(SeuratObj, genes) {
  ### Inputs
  ### SeuratObj = A Seurat object containing UMI counts for the `genes` vector
  ### genes = A character vector of genes to quantify total expression of the genes per cell

  ### Limit the genes to be tested as those present in the object
  genes_in_object <- genes[genes %in% rownames(SeuratObj)]

  ### If only one of the genes are present in the object,
  ### add a metadata column named "nCount_Viral" to the object
  ### and set its value to the counts of that single gene
  if (length(genes_in_object) == 1) {
    SeuratObj@meta.data$nCount_Viral <- SeuratObj@assays$RNA@counts[genes_in_object, ]

    ### If none of the genes are present in the object,
    ### add a metadata column named "nCount_Viral" to the object
    ### and set its value to 0
  } else if (length(genes_in_object) == 0) {
    SeuratObj@meta.data$nCount_Viral <- rep(0)

    ### If more than one of the genes are present in the object,
    ### add a metadata column named "nCount_Viral" to the object
    ### and set its value to the sum counts of those genes
  } else {
    SeuratObj@meta.data$nCount_Viral <- Matrix::colSums(SeuratObj@assays$RNA@counts[genes_in_object, ])
  }

  ### Return the Seurat Object
  return(SeuratObj)
}

### This function calculates the total number of host-derived UMIs per cell in a Seurat object
calculate_host_nUMIs <- function(SeuratObj) {
  ### Inputs:
  ### SeuratObj = A Seurat object containing UMI counts

  ### Define host genes as any genes that are not viral genes
  host_genes <- rownames(SeuratObj)[!rownames(SeuratObj) %in% viral_genes]

  ### Calculate the total UMI counts for all host genes expressed per cell
  SeuratObj$host_nUMI <- colSums(SeuratObj@assays$RNA@counts[host_genes, ])

  ### Return the Seurat object
  return(SeuratObj)
}

### This function calculates the total number of host-derived genes per cell in a Seurat object
calculate_host_nFeatures <- function(SeuratObj, genes = viral_genes) {
  ### Inputs
  ### SeuratObj = A Seurat object containing UMI counts for the `genes` vector
  ### genes = A character vector of genes to quantify total expression of the genes per cell, the default is a vector of viral genes

  ### Load the Matrix library
  require(Matrix)

  ### Define host genes as any genes that are not in the genes vector
  host_genes <- rownames(SeuratObj)[!rownames(SeuratObj) %in% genes]

  ### Calculate the number of host genes expressed per cell and store in a metadata column called "nFeature_Host"
  SeuratObj$nFeature_Host <- Matrix::colSums(SeuratObj@assays$RNA@counts[host_genes, ] > 0)

  ### Return the Seurat object
  return(SeuratObj)
}

### This function adds the cell barcode to a metadata column of a Seurat Object
add_cell_barcodes <- function(SeuratObj) {
  ### Inputs:
  ### SeuratObj = A Seurat object

  ### Collect the cell barcodes from the rownames of the metadata of a Seurat object
  ### And add to a metadata column called "Cell_BC"
  SeuratObj$Cell_BC <- rownames(SeuratObj@meta.data)

  ### Return the Seurat object
  return(SeuratObj)
}

# Infection Classification Functions

### This function will classify cells as infected using a threshold for
### the total viral UMIs expressed per cell.
### Cells with more viral UMIs than the threshold are classified as "Infected."
### Cells with less viral UMIs than the threshold are classified as "Uninfected."
Threshold_Infection_Classifier <- function(x, threshold = 10) {
  ### Inputs
  ### x = Seurat object that has had calculate_viral_nUMIs run on it to calculate the total viral UMIs per cell
  ### threshold = A value for the total viral UMIs that separates infected and uninfected cells

  ### Add a metadata column to the data titled "Threshold_Infection_Classification"
  ### If the total viral UMIs per cell are greater than the threshold, set the Threshold_Infection_Classification to "Infected".
  ### If the total viral UMIs per cell are less than the threshold, set the Threshold_Infection_Classification to "Uninfected".
  x$Threshold_Infection_Classification <- ifelse(x$nCount_Viral > threshold,
                                                 "Infected", "Uninfected"
  )

  ### Return the Seurat object with the threshold infection classification
  return(x)
}

### This function clusters cells by k medoid clustering performed using the pam algorithm
### based on expression of a vector of genes into k clusters
classify_infection_status_k_medoid <- function(Seurat_Obj,
                                               genes = viral_sgmRNA,
                                               k = 2) {
  ### Inputs
  ### SeuratObj = A Seurat object containing UMI counts for the `genes` vector
  ### genes = A character vector of genes to cluster cells on, the default is a vector of viral sgmRNA-derived genes
  ### k = The number of clusters to define. The default value is 2.

  ### Perform k medoids clustering with pam
  classification <- cluster::pam(
    x = t(Seurat_Obj@assays$RNA@scale.data[as.character(genes), ]),
    k = k,
    diss = FALSE,
    metric = "euclidean"
  )

  ### Order cluster ids with cell BC in Seurat Obj
  ordered_annotations <- match(
    names(classification$cluster),
    rownames(Seurat_Obj@meta.data)
  )

  ### Collect cluster ids per cell
  ordered_annotations <- classification$cluster[ordered_annotations]

  ### Add cluster id to Seurat Obj
  Seurat_Obj <- AddMetaData(Seurat_Obj,
                            ordered_annotations,
                            col.name = paste("Infection_Classification_K_Medoid",
                                             k,
                                             sep = "_"
                            )
  )

  ### Determine the mean Total Viral UMIs per infection cluster
  Viral_UMIs_per_Cluster <- Seurat_Obj@meta.data %>%
    group_by_at(.vars = paste("Infection_Classification_K_Medoid",k,sep = "_")) %>%
    summarise(Mean_Viral_UMIs = mean(nCount_Viral))

  ### Set cluster with max mean_viral_UMIs to infected,
  ### min mean_viral_UMIs to bystander, and
  ### remaining clusters to undetermined
  Viral_UMIs_per_Cluster$Classification <- "Undetermined"
  Viral_UMIs_per_Cluster$Classification <- ifelse(
    Viral_UMIs_per_Cluster$Mean_Viral_UMIs == max(Viral_UMIs_per_Cluster$Mean_Viral_UMIs),
    "Infected",
    Viral_UMIs_per_Cluster$Classification
  )
  Viral_UMIs_per_Cluster$Classification <- ifelse(
    Viral_UMIs_per_Cluster$Mean_Viral_UMIs == min(Viral_UMIs_per_Cluster$Mean_Viral_UMIs),
    "Uninfected",
    Viral_UMIs_per_Cluster$Classification
  )

  ### Rename Infection clusters in Seurat_Obj
  Seurat_Obj@meta.data[,paste("Infection_Classification_K_Medoid",k,sep = "_")] <-
    mgsub(string = Seurat_Obj@meta.data[,paste("Infection_Classification_K_Medoid",k,sep = "_")],
          pattern = dplyr::pull(Viral_UMIs_per_Cluster, all_of(paste("Infection_Classification_K_Medoid",k,sep = "_"))),
          replacement = Viral_UMIs_per_Cluster$Classification)

  return(Seurat_Obj)
}

# Functions for Plotting/Data Visualization
### Create a ggplot theme with conserved elements to use throughout the analysis
publication_theme <- theme_classic() +
  theme(
    #text = element_text(family = "Helvetica"),
    plot.title = element_text(hjust = 0.5, size = 8, face = "bold"),
    axis.text = element_text(size = 6),
    axis.title = element_text(size = 8),
    legend.text = element_text(size = 6),
    legend.title = element_text(size = 8),
    strip.text = element_text(size = 8)
  )

### Function to create a tSNE plot with specific formatting
make_tSNE <- function(SeuratObj = Optimized_Seurat, grouping_var, color_palette) {
  ### Inputs
  ### SeuratObj = A Seurat object to be visualized, the default is the Optimized_Seurat object
  ### grouping_var = A metadata variable to color the Seurat object by
  ### color_palette = A vector of colors to use for the plot,
  ### ideally a named vector where each element of the grouping_var vector is a
  ### name in the color_palette vector

  ### Prepare the tSNE colored by the groupinp_var values and colored by the color_palette
  x <- DimPlot(SeuratObj,
               group.by = grouping_var,
               pt.size = 0.1,
               cols = color_palette,
               combine = FALSE
  )

  ### Format the tSNE with no x or y axis labels, add the publication theme, remove axis ticks and text
  x <- x[[1]] +
    labs(
      x = element_blank(),
      y = element_blank()
    ) +
    publication_theme +
    theme(
      axis.text = element_blank(),
      axis.ticks = element_blank()
    ) +
    coord_equal()

  ### Return the final tSNE
  return(x)
}

# edgeR Functions

## Load gene detector function
## This function identifies genes expressed in at least a certain percent of cells (called the threshold).
## Subsetting edgeR analysis to these genes improves the speed and efficiency of edgeR quantification,
## and since these genes are the most likely to be interesting/significant because genes expressed in
## few cells are likely not significantly differentially expressed, it is reasonable to limit analysis to these genes in edgeR analysis.

## Based on code from Roosheel Patel and modified by Phil Cohen, Comments added by Phil Cohen
detect_expressed_genes <- function(SeuratObj, assay = "RNA", threshold) {
  ### Inputs
  ### SeuratObj = A Seurat object containing counts data.
  ### The function will look for expression among cells per active identity.
  ### If you want to subset to genes expressed in different identities, you will need to change the active identity of the object.
  ### assay = The assay to look into for gene expression. These counts will later be used for edgeR. By default, this is the RNA assay
  ### threshold = A threshold for the percent of cells that must express a gene in order to be quantified

  ### Make an empty vector of genes
  genes <- c()

  ### Run a for loop going along each identity of the seurat object
  for (i in 1:(length(unique(SeuratObj@active.ident))))
  {
    ### Subset the seurat object to a given identity
    cluster <- subset(SeuratObj, idents = levels(SeuratObj)[i])

    ### Pull the counts from the selected assay for cells within the identity
    cluster_df <- cluster@assays[[assay]]@counts %>% as.data.frame()

    ### Calculate the number of cells in the cluster expressing each gene
    genes_df <- as.data.frame(rowMeans(cluster_df > 0))

    ### Subset the genes dataframe to rows where the percent of cells expressing a given gene is above the threshold value
    filtered_df <- subset(x = genes_df, subset = rowMeans(cluster_df > 0) > threshold)

    ### Append the genes vector with the selected gene names
    genes <- c(genes, rownames(filtered_df))
  }

  ### Remove duplicate genes from the output
  genes_list <- unique(genes)

  ### Return the gene list
  return(genes_list)
}


### Adapted from https://github.com/csoneson/conquer_comparison/blob/master/scripts/apply_edgeRQLFDetRate.R
### From Brad Rosenberg; Comments added by Phil Cohen
### Import edgeR
require(edgeR)
run_edgeRQLFDetRate <- function(seurat, assay = "RNA", genes_to_test) {
  ### Inputs
  ### seurat = A seurat object containing counts for genes_to_test and with metadata for Infection_State assigned
  ### assay = The assay to use for edgeR. By default, this is the RNA assay
  ### genes_to_test = A character vector of genes to test by edgeR

  ### Pull the UMI counts for genes_to_test in assay of the seurat object
  counts <- seurat[[assay]]@counts[genes_to_test, ]

  ### Pull the infection state assignment for each cell
  groups <- seurat$Infection_State

  ### Create a DGEList object using the UMI counts and the infection state assignment
  dge <- DGEList(counts = counts, group = groups)

  ### Calculate norm factors for the DGEList object
  dge <- calcNormFactors(dge)

  ### Calculate the cell detection rate, which is the z scaled fraction of genes expressed per cell
  cdr <- scale(Matrix::colMeans(counts > 0))

  ### Create a design matrix containing cell detection rate and infection state assignments
  design <- model.matrix(~ 0 + cdr + groups)

  ### Reformat the column names for the design matrix to remove the string "groups" from each column name
  colnames(design) <- gsub(x = colnames(design), pattern = "groups", replacement = "")

  ### Estimate the dispersion of each gene in the DGElist object according to the design matrix
  dge <- estimateDisp(dge, design = design)

  ### Fit a quasi-likelihood generalized linear model to the DGEList object according to the design matrix
  fit <- glmQLFit(dge, design = design)

  ### Prepare a contrast matrix for pairwise comparisons between infected, bystander, and mock cells according to the design matrix
  contrasts <- makeContrasts(
    Infected_Mock = Infected - Mock,
    Infected_Bystander = Infected - Bystander,
    Bystander_Mock = Bystander - Mock,
    levels = design
  )

  ### Perform quasi-likelihood F test of the generalized linear model across each contrast
  res <- lapply(colnames(contrasts), function(x) {
    qlf <- glmQLFTest(fit, contrast = contrasts[, x])
    return(qlf)
  })

  ### Name the results of the test according to the contrast tested
  names(res) <- colnames(contrasts)

  ### Return the results
  return(res)
}

### Adapted from https://github.com/csoneson/conquer_comparison/blob/master/scripts/apply_edgeRQLFDetRate.R
### From Brad Rosenberg; Comments added by Phil Cohen
run_edgeRQLFDetRate_ANOVA <- function(seurat, assay = "RNA", genes_to_test) {
  ### Inputs
  ### seurat = A seurat object containing counts for genes_to_test and with metadata for Infection_State assigned
  ### assay = The assay to use for edgeR. By default, this is the RNA assay
  ### genes_to_test = A character vector of genes to test by edgeR

  ### Pull the UMI counts for genes_to_test in assay of the seurat object
  counts <- seurat[[assay]]@counts[genes_to_test, ]

  ### Pull the infection state assignment for each cell
  groups <- seurat$Infection_State

  ### Create a DGEList object using the UMI counts and the infection state assignment
  dge <- DGEList(counts = counts, group = groups)

  ### Calculate norm factors for the DGEList object
  dge <- calcNormFactors(dge)

  ### Calculate the cell detection rate, which is the z scaled fraction of genes expressed per cell
  cdr <- scale(Matrix::colMeans(counts > 0))

  ### Create a design matrix containing cell detection rate and infection state assignments
  design <- model.matrix(~ 0 + cdr + groups)

  ### Reformat the column names for the design matrix to remove the string "groups" from each column name
  colnames(design) <- gsub(x = colnames(design), pattern = "groups", replacement = "")

  ### Estimate the dispersion of each gene in the DGElist object according to the design matrix
  dge <- estimateDisp(dge, design = design)

  ### Fit a quasi-likelihood generalized linear model to the DGEList object according to the design matrix
  fit <- glmQLFit(dge, design = design)

  ### Prepare a contrast matrix for comparisons between infected, bystander, and mock cells according to the design matrix
  contrasts <- makeContrasts(
    Infected_Mock = Infected - Mock,
    Infected_Bystander = Infected - Bystander,
    Bystander_Mock = Bystander - Mock,
    levels = design
  )

  ### Perform quasi-likelihood F test of the generalized linear model across any/all contrasts
  res <- glmQLFTest(fit, contrast = contrasts)

  ### Return the results
  return(res)
}
